#!/bin/bash

DEBUG=0

rm -rf old-tags
cp tdtags old-tdtags

if [[ "$1" == "DEBUG" ]]; then
  DEBUG=1
fi

# Pre Script Settings#{{{
cd ~/Documents/git-repos/remote-github/data-extract-from-website

# Unset globbing
set -f

# Now readarray delimits with newlines
IFS='
'

# No case sensitivity for string matching
shopt -s nocasematch
#}}}

# Get Products that are on sale#{{{

readarray PRODUCTS < ./products-to-look-for
readarray EMAILS < ./emails

# If debug is on, remove all emails except the first (which is mine)
NUM_OF_EMAILS=${#EMAILS[@]}
if (( $DEBUG == 1 )); then
  debug_count=0
  for((i=0;i<$NUM_OF_EMAILS;i++)); do
    echo "debug_count = $debug_count"
    if (( $debug_count > 0 )); then
      EMAILS[$i]=""
      echo "EMAILS[i] = $EMAILS[$i]"
    fi
    ((debug_count++))
  done
fi

touch fetchedPage
rm -rf fetchedPage

echo "Downloading webpage: http://www.pickapart.ca/"
wget -O fetchedPage "http://www.pickapart.ca/"

DATE_RANGE=$(command grep -Eo '[[:alpha:]]{3} [[:digit:]]{2}, [[:digit:]]{4} - [[:alpha:]]{3} [[:digit:]]{2}, [[:digit:]]{4}' fetchedPage)

# -e lets the \n act as a newline character
echo -e "Pick a Part has the following on sale from $DATE_RANGE:\n" > foundProducts



# At the end of all td tags start a new line.
sed -i "s@</td>@</td>\n@g" fetchedPage

# Open fetchedPage#{{{
declare -a ARRAY
exec 10<&0
fileName="fetchedPage"
exec < $fileName
let count=0
#}}}
# Each line gets stored in an array.#{{{
while read LINE; do
  ARRAY[$count]=$LINE
  ((count++))
done
#}}}
# Close fetchedPage#{{{
exec 0<&10 10<&-
#}}}

# Used to find the lines we need.
regex="<td align='center' valign='top'>[[:print:]]*</td>"

touch tdtags
rm -rf tdtags
touch tdtags

ELEMENTS=${#ARRAY[@]}
firstLine=0


# make tdtags file that contains only the useful information.
for((i=0;i<$ELEMENTS;i++)); do
  if [[ ${ARRAY[${i}]} =~ $regex ]] ; then
    if [[ $firstLine<1 ]]; then
      echo ${BASH_REMATCH[0]} > tdtags
      let firstLine=$firstLine+1
    else
      echo ${BASH_REMATCH[0]} >> tdtags
    fi
  fi
done

# Remove all unwanted values from tdtags
# This generates a file tdtags that contains the item on one line, followed by
# the price on the second line.
# remove "<td align='center' valign='top'>" from each line
sed -i "s@<td align='center' valign='top'>@@g" tdtags
# remove </td> tags
sed -i "s@</td>@@g" tdtags
# removes the <br> tag and replaces it with " - ". That way the product name and
# price are separated by a " - "
sed -i "s@<br>@ - @g" tdtags

# Put the fetched items from tdtags into an array
readarray FETCHED_ITEMS < ./tdtags
NUM_PRODUCTS_FOUND=0

echo "Searching webpage for items of interest:"
for PRODUCT in "${PRODUCTS[@]}"
do
  # Skip comments when parsing
  [[ ${PRODUCT:0:1} == "#" ]] && continue
  # Skip empty lines when parsing
  [[ ${PRODUCT:1:1} == "" ]] && continue

  # Remove trailing newline from the name
  PRODUCT=$(echo ${PRODUCT} | tr -d '\n')

  # See if PRODUCT is found on the webpage
  # If it is, print it to the console, and append it to foundProducts file.
  for FETCHED_ITEM in "${FETCHED_ITEMS[@]}"
  do
    if [[ $FETCHED_ITEM =~ $PRODUCT ]]; then
      echo -n "- $FETCHED_ITEM" >> foundProducts
      echo -n "Found:  $FETCHED_ITEM"
      ((NUM_PRODUCTS_FOUND++))
    fi
  done

done

#remove duplicate entries in foundProducts
awk '!a[$0]++' foundProducts > tmp && mv tmp foundProducts
#}}}

# Find new or missing cars on the lot#{{{
echo "Downloading car list from webpage: http://parts.pickapart.ca/index.php"
# This submits a form on pickapart.ca to get a list of saturns in the lot.
curl --form-string 'md=submit' --form-string 'model=Saturn' 'http://parts.pickapart.ca/index.php' > saturn-car-list

dos2unix saturn-car-list

# -e lets the \n act as a newline character
#echo -e "\n\nThese Cars:\n" >> foundProducts
echo -e "\n\n" >> foundProducts


# Open fetchedPage
declare -a ARRAY
exec 10<&0
fileName="saturn-car-list"
exec < $fileName
let count=0

# Each line gets stored in an array.
while read LINE; do
  ARRAY[$count]=$LINE
  ((count++))
done

exec 0<&10 10<&-

# Used to find the lines we need.
regex="<tr [[:print:]]*<a href=\"http[[:print:]]*</tr>"

touch tdtags
rm -rf tdtags
touch tdtags

ELEMENTS=${#ARRAY[@]}
firstLine=0


# make tdtags file that contains only the useful information.
for((i=0;i<$ELEMENTS;i++)); do
  if [[ ${ARRAY[${i}]} =~ $regex ]] ; then
    if [[ $firstLine<1 ]]; then
      echo ${BASH_REMATCH[0]} > tdtags
      let firstLine=$firstLine+1
    else
      echo ${BASH_REMATCH[0]} >> tdtags
    fi
  fi
done

# At the end of all td tags start a new line.
sed -i "s@</td>@</td>\n@g" tdtags


# Delete all lines containing <tr bgcolor=
sed -i '/<tr bgcolor=/d' tdtags

# remove "<td>" from each line
sed -i "s@<td>@@g" tdtags
# remove "</td>" from each line
sed -i "s@</td>@@g" tdtags
# remove "</tr>" from each line
sed -i "s@</tr>@@g" tdtags


# Open tdtags
declare -a CAR_ARRAY
exec 10<&0
fileName="tdtags"
exec < $fileName
let count=0

# Each line gets stored in an array.
while read LINE; do
  CAR_ARRAY[$count]=$LINE
  ((count++))
done

exec 0<&10 10<&-

# Car array now contains all the car information for saturns.
# Note that bash does not have 2D arrays, so it is stored in a 1D array.

# index 0 = Date added
# index 1 = Make
# index 2 = Model
# index 3 = Year
# index 4 = Body Style (ex. 4DSDN, 2DCPE etc)
# index 5 = Engine
# index 6 = Transmission
# index 7 = Description
# index 8 = Row # (The row at the lot that the car is in)
# index 9 = Stock #
# index 10 restarts for a new car

# number of cars = size of array / 10
num_of_cars=$((count / 10))

echo "Number of cars is: $num_of_cars"

readarray NUMBER_OF_CARS_PREVIOUS < ./number_of_cars

echo "Previous num of cars is: ${NUMBER_OF_CARS_PREVIOUS[0]}"

diff=$((NUMBER_OF_CARS_PREVIOUS[0] - num_of_cars))

if (( ${NUMBER_OF_CARS_PREVIOUS[0]} > $num_of_cars )); then
  echo "$diff less car(s) today"
  echo "$diff less car(s) today" >> foundProducts
  echo "$num_of_cars" > number_of_cars
elif (( ${NUMBER_OF_CARS_PREVIOUS[0]} < $num_of_cars )); then
  diff=$((diff*-1))
  echo "$diff more car(s) today"
  echo "$diff more car(s) today" >> foundProducts
  echo "$num_of_cars" > number_of_cars
else
  echo "No Change"
fi
#}}}

# Email#{{{

# Used to echo if an email is commented
COUNT=0
echo "Sending emails..."
for EMAIL in "${EMAILS[@]}"
do
  # Used to echo if the line is commented
  COUNT=$((COUNT + 1))
  # Skip comments when parsing
  # Also if it is commented print to the log and console that it is commented.
  [[ ${EMAIL:0:1} == "#" ]] && echo "Line #$COUNT is Commented"  && continue
  # Skip empty lines when parsing
  [[ ${EMAIL:1:1} == "" ]] && continue

  # If more than one item was found, send an email saying that x was found
  if [[ $NUM_PRODUCTS_FOUND > 0 ]]; then
    mutt -s "Pick a Part Alert: $DATE_RANGE" $EMAIL < foundProducts

    # otherwise, Send an email saying that there is no items.
  else
    echo "Pick a Part has nothing on sale this week ($DATE_RANGE) that you are looking for." | mutt -s "Pick a Part Alert: $DATE_RANGE" $EMAIL
  fi
  # -n removes trailing newlines
  echo -n "Sent to $EMAIL"
done
#}}}

# Cleanup#{{{
if (( $DEBUG == 1 )); then
  mkdir debug

  mv fetchedPage debug/
  mv foundProducts debug/
  mv saturn-car-list debug/
else
  echo "cleanup..."
  rm -rf fetchedPage
  rm -rf foundProducts
  rm -rf saturn-car-list
fi

unset IFS
set +f
#}}}

