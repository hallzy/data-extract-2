#!/bin/bash

DEBUG=0

rm -rf old-tags
cp tdtags old-tdtags

if [[ "$1" == "DEBUG" ]]; then
  DEBUG=1
fi

# Pre Script Settings#{{{
cd ~/Documents/git-repos/remote-github/data-extract-from-website

# Unset globbing
set -f

# Now readarray delimits with newlines
IFS='
'

# No case sensitivity for string matching
shopt -s nocasematch
#}}}

# Get Products that are on sale#{{{

readarray PRODUCTS < ./products-to-look-for
readarray EMAILS < ./emails

# If debug is on, remove all emails except the first (which is mine)
NUM_OF_EMAILS=${#EMAILS[@]}
if (( $DEBUG == 1 )); then
  debug_count=0
  for((i=0;i<$NUM_OF_EMAILS;i++)); do
    echo "debug_count = $debug_count"
    if (( $debug_count > 0 )); then
      EMAILS[$i]=""
      echo "EMAILS[i] = $EMAILS[$i]"
    fi
    ((debug_count++))
  done
fi

touch fetchedPage
rm -rf fetchedPage

echo "Downloading webpage: http://www.pickapart.ca/"
wget -O fetchedPage "http://www.pickapart.ca/"

DATE_RANGE=$(command grep -Eo '[[:alpha:]]{3} [[:digit:]]{2}, [[:digit:]]{4} - [[:alpha:]]{3} [[:digit:]]{2}, [[:digit:]]{4}' fetchedPage)

# -e lets the \n act as a newline character
echo -e "Pick a Part has the following on sale from $DATE_RANGE:\n" > email-body



# At the end of all td tags start a new line.
sed -i "s@</td>@</td>\n@g" fetchedPage

# Open fetchedPage#{{{
declare -a ARRAY
exec 10<&0
fileName="fetchedPage"
exec < $fileName
let count=0
#}}}
# Each line gets stored in an array.#{{{
while read LINE; do
  ARRAY[$count]=$LINE
  ((count++))
done
#}}}
# Close fetchedPage#{{{
exec 0<&10 10<&-
#}}}

# Used to find the lines we need.
regex="<td align='center' valign='top'>[[:print:]]*</td>"

touch tdtags
rm -rf tdtags
touch tdtags

ELEMENTS=${#ARRAY[@]}
firstLine=0


# make tdtags file that contains only the useful information.
for((i=0;i<$ELEMENTS;i++)); do
  if [[ ${ARRAY[${i}]} =~ $regex ]] ; then
    if [[ $firstLine<1 ]]; then
      echo ${BASH_REMATCH[0]} > tdtags
      let firstLine=$firstLine+1
    else
      echo ${BASH_REMATCH[0]} >> tdtags
    fi
  fi
done

# Remove all unwanted values from tdtags
# This generates a file tdtags that contains the item on one line, followed by
# the price on the second line.
# remove "<td align='center' valign='top'>" from each line
sed -i "s@<td align='center' valign='top'>@@g" tdtags
# remove </td> tags
sed -i "s@</td>@@g" tdtags
# removes the <br> tag and replaces it with " - ". That way the product name and
# price are separated by a " - "
sed -i "s@<br>@ - @g" tdtags

# Put the fetched items from tdtags into an array
readarray FETCHED_ITEMS < ./tdtags
NUM_PRODUCTS_FOUND=0

echo "Searching webpage for items of interest:"
for PRODUCT in "${PRODUCTS[@]}"
do
  # Skip comments when parsing
  [[ ${PRODUCT:0:1} == "#" ]] && continue
  # Skip empty lines when parsing
  [[ ${PRODUCT:1:1} == "" ]] && continue

  # Remove trailing newline from the name
  PRODUCT=$(echo ${PRODUCT} | tr -d '\n')

  # See if PRODUCT is found on the webpage
  # If it is, print it to the console, and append it to email-body file.
  for FETCHED_ITEM in "${FETCHED_ITEMS[@]}"
  do
    if [[ $FETCHED_ITEM =~ $PRODUCT ]]; then
      echo -n "- $FETCHED_ITEM" >> email-body
      echo -n "Found:  $FETCHED_ITEM"
      ((NUM_PRODUCTS_FOUND++))
    fi
  done

done

#remove duplicate entries in email-body
awk '!a[$0]++' email-body > tmp && mv tmp email-body
#}}}

# Find new or missing cars on the lot#{{{
echo "Downloading car list from webpage: http://parts.pickapart.ca/index.php"
# This submits a form on pickapart.ca to get a list of saturns in the lot.
curl --form-string 'md=submit' --form-string 'model=Saturn' 'http://parts.pickapart.ca/index.php' > saturn-car-list

dos2unix saturn-car-list

# -e lets the \n act as a newline character
#echo -e "\n\nThese Cars:\n" >> email-body
echo -e "\n\n" >> email-body

# Remove all lines from html that are not necessary at all (before the parts we don't need, and after)#{{{

# Open fetchedPage
declare -a ARRAY
exec 10<&0
fileName="saturn-car-list"
exec < $fileName
let count=0

# Each line gets stored in an array.
while read LINE; do
  ARRAY[$count]=$LINE
  ((count++))
done

exec 0<&10 10<&-

# Used to find the lines we need.
regex="<tr [[:print:]]*<a href=\"http[[:print:]]*</tr>"
#}}}

# make tdtags file that contains only the useful information.#{{{

touch tdtags
rm -rf tdtags
touch tdtags

ELEMENTS=${#ARRAY[@]}
firstLine=0


for((i=0;i<$ELEMENTS;i++)); do
  if [[ ${ARRAY[${i}]} =~ $regex ]] ; then
    if [[ $firstLine<1 ]]; then
      echo ${BASH_REMATCH[0]} > tdtags
      let firstLine=$firstLine+1
    else
      echo ${BASH_REMATCH[0]} >> tdtags
    fi
  fi
done

# At the end of all td tags start a new line.
sed -i "s@</td>@</td>\n@g" tdtags


# Delete all lines containing <tr bgcolor=
sed -i '/<tr bgcolor=/d' tdtags

# remove "<td>" from each line
sed -i "s@<td>@@g" tdtags
# remove "</td>" from each line
sed -i "s@</td>@@g" tdtags
# remove "</tr>" from each line
sed -i "s@</tr>@@g" tdtags
#}}}

# Populate Arrays for the data for the new cars#{{{

# Open tdtags
declare -a CAR_MODEL
declare -a CAR_YEAR
declare -a CAR_BODY_STYLE
declare -a CAR_ENGINE
declare -a CAR_TRANSMISSION
declare -a CAR_DESCRIPTION
declare -a CAR_STOCK_NUMBERS
exec 10<&0
fileName="tdtags"
exec < $fileName
let car_model_count=0
let car_year_count=0
let car_body_style_count=0
let car_engine_count=0
let car_transmission_count=0
let car_description_count=0
let car_stock_array_count=0

let count=0
# CAR_ARRAY now contains all the car information for saturns.
# Note that bash does not have 2D arrays, so it is stored in a 1D array.

# index 0 = Date added
# index 1 = Make
# index 2 = Model
# index 3 = Year
# index 4 = Body Style (ex. 4DSDN, 2DCPE etc)
# index 5 = Engine
# index 6 = Transmission
# index 7 = Description
# index 8 = Row # (The row at the lot that the car is in)
# index 9 = Stock #

# index 10 = Date added for the next car
# etc
# Each line gets stored in an array.

while read LINE; do
  # Get car models
  if (( $count % 10 == 2 )); then
    CAR_MODEL[$car_model_count]=$LINE
    ((car_model_count++))
  # Get car year
  elif (( $count % 10 == 3 )); then
    CAR_YEAR[$car_year_count]=$LINE
    ((car_year_count++))
  # Get car body styles
  elif (( $count % 10 == 4 )); then
    CAR_BODY_STYLE[$car_body_style_count]=$LINE
    ((car_body_style_count++))
  # Get car engine type
  elif (( $count % 10 == 5 )); then
    CAR_ENGINE[$car_engine_count]=$LINE
    ((car_engine_count++))
  # Get car transmission type
  elif (( $count % 10 == 6 )); then
    CAR_TRANSMISSION[$car_transmission_count]=$LINE
    ((car_transmission_count++))
  # Get car description
  elif (( $count % 10 == 7 )); then
    CAR_DESCRIPTION[$car_description_count]=$LINE
    ((car_description_count++))
  # Get stock numbers
  elif (( $count % 10 == 9 )); then
    CAR_STOCK_NUMBERS[$car_stock_array_count]=$LINE
    ((car_stock_array_count++))
  fi

  ((count++))
done

exec 0<&10 10<&-

# number of cars = size of array / 10
num_of_cars_current=$car_stock_array_count
#}}}

# Populate Arrays for the data for the old cars#{{{

# Open tdtags
declare -a OLD_CAR_MODEL
declare -a OLD_CAR_YEAR
declare -a OLD_CAR_BODY_STYLE
declare -a OLD_CAR_ENGINE
declare -a OLD_CAR_TRANSMISSION
declare -a OLD_CAR_DESCRIPTION
declare -a OLD_CAR_STOCK_NUMBERS
exec 10<&0
fileName="old-tdtags"
exec < $fileName
let old_car_model_count=0
let old_car_year_count=0
let old_car_body_style_count=0
let old_car_engine_count=0
let old_car_transmission_count=0
let old_car_description_count=0
let old_car_stock_array_count=0

let count=0
# CAR_ARRAY now contains all the car information for saturns.
# Note that bash does not have 2D arrays, so it is stored in a 1D array.

while read LINE; do
  # Get car models
  if (( $count % 10 == 2 )); then
    OLD_CAR_MODEL[$old_car_model_count]=$LINE
    ((old_car_model_count++))
  # Get car year
  elif (( $count % 10 == 3 )); then
    OLD_CAR_YEAR[$old_car_year_count]=$LINE
    ((old_car_year_count++))
  # Get car body styles
  elif (( $count % 10 == 4 )); then
    OLD_CAR_BODY_STYLE[$old_car_body_style_count]=$LINE
    ((old_car_body_style_count++))
  # Get car engine type
  elif (( $count % 10 == 5 )); then
    OLD_CAR_ENGINE[$old_car_engine_count]=$LINE
    ((old_car_engine_count++))
  # Get car transmission type
  elif (( $count % 10 == 6 )); then
    OLD_CAR_TRANSMISSION[$old_car_transmission_count]=$LINE
    ((old_car_transmission_count++))
  # Get car description
  elif (( $count % 10 == 7 )); then
    OLD_CAR_DESCRIPTION[$old_car_description_count]=$LINE
    ((old_car_description_count++))
  # Get stock numbers
  elif (( $count % 10 == 9 )); then
    OLD_CAR_STOCK_NUMBERS[$old_car_stock_array_count]=$LINE
    ((old_car_stock_array_count++))
  fi

  ((count++))
done

exec 0<&10 10<&-
#}}}

# Find new cars on the lot#{{{

let found=0
let count=0
let new_car_array_count=0
declare -a NEW_CARS_ARRAY

# Find New Cars
for NEW_NUMBER in "${CAR_STOCK_NUMBERS[@]}"
do
  for OLD_NUMBER in "${OLD_CAR_STOCK_NUMBERS[@]}"
  do
    # OLD_NUMBER=$(echo ${OLD_NUMBER} | tr -d '\n')
    # Remove trailing newlines
    if [[ $NEW_NUMBER == "$OLD_NUMBER" ]]; then
      # new number exists in old number
      found=1
      break
    fi
  done
  # If the number was not found, we have a new car
  if (( "$found" == "0" )); then
    echo "New Car: $count - $NEW_NUMBER"
    NEW_CARS_ARRAY[$new_car_array_count]=$count
    ((new_car_array_count++))
  fi
  ((count++))
  found=0
done
#}}}

#Find cars that have been removed#{{{

let found=0
let count=0
let old_car_array_count=0
declare -a OLD_CARS_ARRAY

# Find Cars that have been removed
for OLD_NUMBER in "${OLD_CAR_STOCK_NUMBERS[@]}"
do
  # OLD_NUMBER=$(echo ${OLD_NUMBER} | tr -d '\n')
  for NEW_NUMBER in "${CAR_STOCK_NUMBERS[@]}"
  do
    # Remove trailing newlines
    if [[ $NEW_NUMBER == "$OLD_NUMBER" ]]; then
      # new number exists in old number
      found=1
      break
    fi
  done
  # If the number was not found, we have a new car
  if (( "$found" == "0" )); then
    echo "Old Car: $count - $OLD_NUMBER"
    OLD_CARS_ARRAY[$old_car_array_count]=$count
    ((old_car_array_count++))
  fi
  ((count++))
  found=0
done
#}}}

# Append new cars to email body#{{{

if (( "$new_car_array_count" > "0" )); then
  echo "New Cars on the Lot:" >> email-body
fi

for NEW_CAR in "${NEW_CARS_ARRAY[@]}"
do
  echo "${CAR_STOCK_NUMBERS[${NEW_CAR}]}: ${CAR_YEAR[${NEW_CAR}]} ${CAR_MODEL[${NEW_CAR}]} - ${CAR_BODY_STYLE[${NEW_CAR}]} - ${CAR_ENGINE[${NEW_CAR}]} - ${CAR_TRANSMISSION[${NEW_CAR}]} Transmission - ${CAR_DESCRIPTION[${NEW_CAR}]}" >> email-body
done
#}}}

# Append cars removed from the lot to the email body#{{{

if (( "$old_car_array_count" > "0" )); then
  if (( "$new_car_array_count" > "0" )); then
    echo -e "\n" >> email-body
  fi
  echo "Cars that have been removed from the lot:" >> email-body
fi

for OLD_CAR in "${OLD_CARS_ARRAY[@]}"
do
  echo "${OLD_CAR_STOCK_NUMBERS[${OLD_CAR}]}: ${OLD_CAR_YEAR[${OLD_CAR}]} ${OLD_CAR_MODEL[${OLD_CAR}]} - ${OLD_CAR_BODY_STYLE[${OLD_CAR}]} - ${OLD_CAR_ENGINE[${OLD_CAR}]} - ${OLD_CAR_TRANSMISSION[${OLD_CAR}]} Transmission - ${OLD_CAR_DESCRIPTION[${OLD_CAR}]}" >> email-body
done
#}}}

#}}}

# Email#{{{

# Used to echo if an email is commented
COUNT=0
echo "Sending emails..."
for EMAIL in "${EMAILS[@]}"
do
  # Used to echo if the line is commented
  COUNT=$((COUNT + 1))
  # Skip comments when parsing
  # Also if it is commented print to the log and console that it is commented.
  [[ ${EMAIL:0:1} == "#" ]] && echo "Line #$COUNT is Commented"  && continue
  # Skip empty lines when parsing
  [[ ${EMAIL:1:1} == "" ]] && continue

  # If more than one item was found, send an email saying that x was found
  if [[ $NUM_PRODUCTS_FOUND > 0 ]]; then
    mutt -s "Pick a Part Alert: $DATE_RANGE" $EMAIL < email-body

    # otherwise, Send an email saying that there is no items.
  else
    echo "Pick a Part has nothing on sale this week ($DATE_RANGE) that you are looking for." | mutt -s "Pick a Part Alert: $DATE_RANGE" $EMAIL
  fi
  # -n removes trailing newlines
  echo -n "Sent to $EMAIL"
done
#}}}

# Cleanup#{{{
if (( $DEBUG == 1 )); then
  mkdir debug

  mv fetchedPage debug/
  mv email-body debug/
  mv saturn-car-list debug/
else
  echo "cleanup..."
  rm -rf fetchedPage
  rm -rf email-body
  rm -rf saturn-car-list
fi

unset IFS
set +f
#}}}

